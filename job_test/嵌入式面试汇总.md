# 嵌入式面试知识点汇总

## 目录大纲

* [一、static、extern、volatile](#一、static、extern、volatile)
* [二、结构体与共用体](#二、结构体与共用体)
* [三、ARM架构与x86架构](#三、ARM架构与x86架构)
* [四、通信协议及总线](#四、通信协议及总线)
* [五、字节存储模式](#五、字节存储模式)
* [六、ARM指令和Thumb指令](#六、ARM指令和Thumb指令)
* [七、单片机的开漏输出与推挽输出的区别](#七、单片机的开漏输出与推挽输出的区别)
* [八、Linux中的并发控制（锁机制）](#八、Linux中的并发控制（锁机制）)
* [九、中断上下文与进程上下文](#九、中断上下文与进程上下文)
* [十、Linux中断机制](#十、Linux中断机制)
* [十一、无线音乐播放系统项目](#十一、无线音乐播放系统项目)
* [十二、Linux系统启动流程](#十二、Linux系统启动流程)
* [十三、硬件高速缓存（Cache）](#十三、硬件高速缓存（Cache）)
* [十四、Linux内核空间与用户空间](#十四、Linux内核空间与用户空间)
* [十五、排序算法](#十五、排序算法)
* [十六、进程间通信](#十六、进程间通信)

## 一、static、extern、volatile

### 1.1 static关键字

一般程序把动态数据存放在堆区，局部变量存放在栈区。局部变量一般会随着函数的退出而释放空间，全局变量、静态数据、常量都在全局数据区（静态存储区）在编译时分配内存，程序结束后由系统释放。

#### 1.1.1 全局变量

全局变量在全局数据区分配内存，未经初始化的全局变量会被程序自动初始化为0。

未加static修饰的全局变量默认是有外部链接的，作用域是整个工程，在一个文件中定义的全局变量，在另一个文件中可以通过`extern`全局变量的声明引用该变量。

用static修饰的全局变量，作用域是该文件中，其他文件即使使用`extern`关键字也不能访问。

#### 1.1.2 局部变量

局部变量不加`static`修饰符默认是`auto`修饰的。程序为局部变量在栈区分配内存，函数退出后系统回收栈区空间，释放局部变量。

`static`修饰的局部变量叫做`静态局部变量`，其在全局数据区（静态存储区）在编译时分配空间，变量的作用域依然只是函数体内，但变量的生命周期从程序运行开始到程序运行结束。

#### 1.1.3 函数

`static`修饰的函数表明该函数只在本文件内可见，不能被其他文件在外部调用，因此在多文件编译时可以在不同文件中定义相同名称的静态函数而不会引发编译冲突。

### 1.2 extern关键字

* 当它与"C"一起连用。如：extern "C" void fun(int a); 这个高速编译器在编译fun这个函数名时安C的规则去翻译相应的函数名，而不是C++,因为C++在翻译的时候会把这个fun名字变得面目全非，以支持C++的函数重载。
* 当extern直接放在变量名前和函数名前时。它可以使得你再多个模块之间共享该变量或者该函数，即你在一个模块中定义它，并在其他模块中使用extern，因为它没有使用头文件，所以清楚地表明它只在少数模块之间共享。

extern和static不能同时修饰一个变量。extern是在链接阶段起作用。

### 1.3 volatile关键字

一个定义为volatile的变量是说该变量拒绝编译器优化，在用到这个变量时必须每次从内存地址中重新读取这个变量的值，而不是使用保存在寄存器里的备份。如下情况会用到volatile关键字：

* （1）并行设备的硬件寄存器（如状态寄存器）；
* （2）一个中断服务子程序中会访问到的非自动变量（Non-automatic variables）；
* （3）多线程应用中被几个任务共享的变量。

[@top](#嵌入式面试知识点汇总)

## 二、结构体与共用体

结构体的定义本身仅仅是一个“设计/蓝图”，其并不占用任何存储空间，当其实例化之后，实例才是真正占用的内存空间。

结构体的长度的简单计算结果是所有成员长度之和（1=$2^{0}$字节对齐模式）。

* 注：若使用其他字节对齐模式的话，其空间长度的计算需要按照字节对齐模式相应改变。

共用体的诸成员共同使用同一起始空间，共用体的长度是共用体中成员的最大长度成员的长度。

### 2.1 字节对齐模式

`struct{...}__align(num)`用来指定字节对齐模式，按照num字节来对齐，num为2的整数次幂。`__packed`是进行一字节对齐

[@top](#嵌入式面试知识点汇总)

## 三、ARM架构与x86架构

`ARM(Advanced RSCI Mechine)`，其采用`RISC(Reduced Instruction Set Computers，精简指令集计算集)`。ARM处理器本身定位于嵌入式平台，应付轻量级、目的单一明确的程序。

`x86`定位于桌面和服务器，这些平台上很多应用是计算密集型的，比如多媒体编辑、科研计算、模拟等等。其采用`CISC(Complex Instruction Set Computers，复杂指令集计算集)`。

### 3.1 RISC与CISC的区别

* 指令系统：RISC 设计者把主要精力放在那些经常使用的指令上，尽量使它们具有简单高效的特色。对不常用的功能，常通过组合指令来完成。
* 存储器操作：RISC 对存储器操作有限制，使控制简单化；而CISC 机器的存储器操作指令多，操作直接。
* 程序：RISC 汇编语言程序一般需要较大的内存空间，实现特殊功能时程序复杂，不易设计；而CISC 汇编语言程序编程相对简单，科学计算及复杂操作的程序设计相对容易，效率较高。
* 中断：RISC 机器在一条指令执行的适当地方可以响应中断；而CISC 机器是在一条指令执行结束后响应中断。
* CPU芯片电路：RISC CPU 包含有较少的单元电路，因而面积小、功耗低；而CISC CPU 包含有丰富的电路单元，因而功能强、面积大、功耗大。
* 设计周期：RISC 微处理器结构简单，布局紧凑，设计周期短，且易于采用最新技术；CISC 微处理器结构复杂，设计周期长。
* 用户使用：RISC 微处理器结构简单，指令规整，性能容易把握，易学易用；CISC微处理器结构复杂，功能强大，实现特殊功能容易。
* 应用范围：由于RISC 指令系统的确定与特定的应用领域有关，故RISC 机器更适合于专用机；而CISC 机器则更适合于通用机。

目前常见使用RISC的处理器包括DEC Alpha、ARC、`ARM`、`MIPS`、`PowerPC`、SPARC和SuperH等。常见使用CISC的处理器主要有`X86`。

[@top](#嵌入式面试知识点汇总)

## 四、通信协议及总线

### 4.1 通信协议分类

根据数据的传输方向，通信协议分为`单工通信`、`半双工通信`与`全双工通信`。

* 单工通信：在通信过程的任意时刻,信息只能由一方A传到另一方B。
* 半双工通信：在任意时刻,信息既可由A传到B,又能由B传A,但同一时刻智能存在一个方向。
* 全双工通信：在任意时刻,线路上存在A到B和B到A的双向信号传输。

根据数据的同步方式分为：`同步通信`与`异步通信`。

* `异步通信`中的接收方并不知道数据什么时候会到达，收发双方可以有各自自己的时钟。发送方发送的时间间隔可以不均，接收方是在数据的起始位和停止位的帮助下实现信息同步的。

* `同步通讯`协议，发送方在发送数据之前先发出一个特殊的电信号，让接收方准备好接收数据，然后发送方就将以上数据全部连续发出，发送完毕后，再发送一个特殊的电信号表示数据发送结束。

最典型的`SPI`、`I2C`总线协议中都专门有一个SCLK信号线，由通信的一方产生一个CLK，通过CLK信号线传到另一方，双方就就按这个CLK的控制工作，CLK的宽度就是一个数据位的宽度，而CLK的上升或下降沿，就是“起点”标志。这种`在通信过程中明显有个CLK线专门传送同步信号的方式，就是同步通信`。

* 优点：同步通信由于有专用的CLK线控制，因此通信双方较容易实现“同步”，速度较快
* 缺点：对于长距离的通信，同步方式就不行了
  * 一、由于需要专门一个信号线，成本提高。
  * 二、通信线越长，上面的干扰就越多，通信的速度也上不去。

因此同步方式多是作为同一PCB板上芯片级之间的通信接口使用。

而长距离通信多使用`“异步”通信`方式，这里的“异步”不是指通信双方不需要同步，而是指`通信双方之间不使用专用的同步信号线传送CLK，而是各自仅依赖于自己的系统时钟`。

#### 4.1.1 区别

* 1、异步通信是面向字符的通信，而同步通信是面向比特的通信。
* 2、异步通信的单位是字符而同步通信的单位是桢。
* 3、异步通信通过字符起止的开始和停止码抓住再同步的机会，而同步通信则是以数据中抽取同步信息。
* 4、异步通信对时序的要求较低，同步通信往往通过特定的时钟线路协调时序。
* 5、异步通信相对于同步通信效率较低。

### 4.2 IIC总线

IIC总线主要有两根线组成，一根数据线`SDA`一根时钟线`SCLK`，I2C总线通过上拉电阻接正电源。当总线空闲时，两根线均为高电平`（SDL=1、SCL=1）`。每个接到I2C总线上的器件都有唯一的地址。其中，主动发起操作的一方为主机，另外一方为从机。连到总线上的任一器件输出的低电平，都将使总线的信号变低，即各器件的SDA及SCL都是线“与”关系。

#### 4.2.1 器件地址划分

系统中的所有外围器件都具有一个7位的`从方器件专用地址码`，其中高4位为`器件类型`，由生产厂家制定，低3位为`器件引脚定义地址`，由使用者定义。终端挂载在总线上，有主端和从端之分，主端必须是带有CPU的逻辑模块，在同一总线上同一时刻使能有一个主端，可以有多个从端，从端的数量受地址空间和总线的最大电容 400pF的限制。

E2PROM(24c02)的器件引脚中有三个地址引脚`A0、A1、A2`，其4位器件地址为固定的`1010`，引脚地址根据其接线（VCC/GND）决定器件地址。

#### 4.2.2 空闲信号

I2C总线总线的SDA和SCL两条信号线同时处于高电平时，规定为总线的空闲状态。此时各个器件的输出级场效应管均处在截止状态，即释放总线，由两条信号线各自的上拉电阻把电平拉高。

#### 4.2.3 起始位与停止位

* 起始信号：当SCL为高期间，SDA由高到低的跳变。
* 停止信号：当SCL为高期间，SDA由低到高的跳变。

起始和终止信号都是由`主机`发出的，在起始信号产生后，总线就处于被占用的状态，在终止信号产生后，总线就处于空闲状态。

#### 4.2.4 ACK与NACK

发送方每发送一个8位数据，就在时钟脉冲第9个时钟脉冲期间释放SDA（拉高），由接收方返回一个应答信号ACK。接收方平稳拉低SDA表示为`有效应答`（ACK简称应答位），表示接收方已经成功地接收了该数据，接收方没有拉低SDA，则表示为非应答位（NACK），一般表示接收方没有接受成功。如果接收方是主控制器，则在它收到最后一个字节后，发送一个NACK信号，通知从发结束数据发送，并释放SDA线，以便主控接收器发送一个停止位。

#### 4.2.5 E2PROM读写时序

EEPROM有两种写模式，三种读模式；分别是：`字节写`，`页面写`，`当前地址读`，`指定地址读`，`连续读`，其相应的时序图如下。

![字节写](https://github.com/jonewan/markdown/blob/master/job_test/EEPROM%E5%AD%97%E8%8A%82%E5%86%99%E6%97%B6%E5%BA%8F.jpg?raw=true)

![页面写](https://github.com/jonewan/markdown/blob/master/job_test/EEPROM%E8%BF%9E%E7%BB%AD%E5%86%99%E6%97%B6%E5%BA%8F.jpg?raw=true)

![当前地址读](https://github.com/jonewan/markdown/blob/master/job_test/EEPROM%E5%AD%97%E8%8A%82%E8%AF%BB%E6%97%B6%E5%BA%8F.jpg?raw=true)

![指定地址读](https://github.com/jonewan/markdown/blob/master/job_test/EEPROM%E9%80%89%E6%8B%A9%E8%AF%BB%E6%97%B6%E5%BA%8F.jpg?raw=true)

![连续读](https://github.com/jonewan/markdown/blob/master/job_test/EEPROM%E8%BF%9E%E7%BB%AD%E8%AF%BB%E6%97%B6%E5%BA%8F.jpg?raw=true)

### 4.3 SPI总线

SPI（Serial Peripheral Interface）是一种串行同步通讯协议，其主要有四根线，分别为`MISO`、`MOSI`、`SCLK`、`CS`，在SPI传输中，数据是同步进行发送和接收的。SPI总线定义两个及以上设备间的数据传输，提供时钟的设备为主设备（Master），接收时钟的设备为从设备（Slave）。其时序其实很简单，主要是在SCLK的控制下，两个`双向移位寄存器`进行数据交换。

![SPI传输示意图](https://github.com/jonewan/markdown/blob/master/job_test/SPI%E4%BC%A0%E8%BE%93%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg?raw=true)

SPI通过`时钟极性CPOL`与`时钟相位CPHA`控制数据的采样(输入)与输出时机，通过配置控制寄存器SPICR1的这两位SPI传输可以有四种模式，如下图所示：

![SPI采样四种模式](https://raw.githubusercontent.com/jonewan/markdown/master/job_test/SPI%E9%87%87%E6%A0%B7%E6%A8%A1%E5%BC%8F.bmp)

[@top](#嵌入式面试知识点汇总)

## 五、字节存储模式

在计算机中我们是以字节为单位进行存储的，每个地址单元对应一个字节，由于一个寄存器的宽度大于等于一个字节，因此必然存在着如何将多个字节安排的问题，故出现了`大端（Big-Endian）`与`小端（Little-Endian）`存储模式。***大小端存储模式是由CPU架构决定的，不是由操作系统决定的。*** 在Linux中`/usr/include/elf.h`文件定义了不同处理器的大小端模式。Windows中`C:\Program Files (x86)\Windows Kits\8.1\Include\um\winnt.h`定义了不同处理器的大小端模式。

* 大端（Big-Endian）：通俗来讲就是`高低低高`，即，高字节存储在低端内存区域，低字节存储在高端内存区域。
* 小端（Little-Endian）：通俗来讲就是`高高低低`，即，高字节存储在高端内存区域，低字节存储在低端内存区域。
  
`通常一个数据的最左侧为高端字节，最右侧为低端字节。`

用一张图来表示：

![大小端存储](https://raw.githubusercontent.com/jonewan/markdown/master/job_test/%E5%AD%97%E8%8A%82%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F.bmp)

大小端在网络通信中最常使用，在利用socket编程时会使用如下的宏：

```c
#define ntohs(n) //16位数据类型网络字节顺序到主机字节顺序的转换
#define htons(n) //16位数据类型主机字节顺序到网络字节顺序的转换
#define ntohl(n) //32位数据类型网络字节顺序到主机字节顺序的转换
#define htonl(n) //32位数据类型主机字节顺序到网络字节顺序的转换
```

其中互联网使用的网络字节顺序采用大端模式进行编址，而主机字节顺序根据处理器的不同而不同，x86系统用的是小端（Little-endian）存储，而powerPC采用的是大端（Big-endian）存储。

### 5.1 判断一个CPU是大端还是小端的方法

```c
union{
    int a;
    char b;
}cpu;

cpu.a = 1;

return cpu.b == 1;//0：big 1：little
```

```c
int a = 1;
char *p = &a;

return *p == 1;//0:big 1:little
```

### 5.2 LSB&MSB

在计算机的数据传输中，传输的通常是一个一个位（bit），在这些位数据中如何准确解析数据呢？就通过`最高有效位（Most Significant Bit,MSB）`与`最低有效位（Least Significant Bit,LSB）`来确定。`最高有效位（MSB）`指的是一个二进制中最高位的比特，相反，`最低有效位（LSB）`指的是一个二进制中最低位的比特。比如串口发送数据时是LSB先发送，而MSB后发送。在计算机的一个字节（8bit）中，LSB是最右边的位，MSB是最左边的位。

[@top](#嵌入式面试知识点汇总)

## 六、ARM指令和Thumb指令

在ARM的体系结构中，可以工作在三种不同的状态，一是ARM状态，二是Thumb状态及Thumb-2状态，三是调试状态。而ARM状态和Thumb状态可以直接通过某些指令直接切换，都是在运行程序，只不过指令长度不一样而已。

* ARM状态：arm处理器工作于32位指令的状态，所有指令均为32位；
* Thumb状态：arm执行16位指令的状态，即16位状态；
* thumb-2状态：这个状态是ARM7版本的ARM处理器所具有的新的状态，新的thumb-2内核技术兼有16位及32位指令，实现了更高的性能，更有效的功耗及更少地占用内存。总的来说，感觉这个状态除了兼有arm和thumb的优点外，还在这两种状态上有所提升，优化；
* 调试状态：处理器停机时进入调试状态。

### 6.1 ARM状态和Thumb状态切换程序

* 从ARM到Thumb: `LDR R0,=lable+1 BX R0`（状态将寄存器的最低位设置为1，BX指令、R0指令将进入thumb状态）；
* 从ARM到Thumb: `LDR R0,=lable BX R0`（寄存器最低位设置为0，BX指令、R0指令将进入arm状态）。
* 当处理器进行异常处理时，则从异常向量地址开始执行，将自动进入ARM状态。

[@top](#嵌入式面试知识点汇总)

## 七、单片机的开漏输出与推挽输出的区别

推挽输出:可以输出高,低电平,连接数字器件。

* 输出 0 时，N-MOS 导通，P-MOS 高阻，输出0。
* 输出 1 时，N-MOS 高阻，P-MOS 导通，输出1（不需要外部上拉电路）。

开漏输出:输出端相当于三极管的集电极. 要得到高电平状态需要上拉电阻才行. 适合于做电流型的驱动,其吸收电流的能力相对强(一般20ma以内)。

* 输出 0 时，N-MOS 导通，P-MOS 不被激活，输出0。
* 输出 1 时，N-MOS 高阻， P-MOS 不被激活，输出1（需要外部上拉电路）；可以读IO输入电平变化，此模式可以把端口作为双向IO使用。

[@top](#嵌入式面试知识点汇总)

## 八、Linux中的并发控制（锁机制）

一次仅允许一个进程使用的资源称为`临界资源`。属于临界资源的硬件有打印机、磁带机等,软件有消息缓冲队列、变量、数组、缓冲区等。每个进程中访问临界资源的那段代码称为`临界区（Critical Section）`（临界资源是一次仅允许一个进程使用的共享资源）。每次只准许一个进程进入临界区，进入后不允许其他进程进入。不论是硬件临界资源，还是软件临界资源，多个进程必须互斥地对它进行访问

### 8.1 Linux内核的竞态发生的情况

#### 8.1.1 对称多处理器（SMP）的多个CPU间

SMP是一种多个CPU使用共同的系统总线访问共同的外设和存储器的系统模型。在这种情况下，竞态可能发生在两个CPU的进程之间、中断之间、进程与中断之间。

#### 8.1.2 单核进程与其抢占进程间

一个进程在内核态执行时消耗完自己的时间片或者被其他高优先级的进程抢占。

#### 8.1.3 中断与进程之间

若中断服务程序访问进程正在访问的资源，就会产生竞态。中断嵌套也有可能导致竞态。

访问共享资源的代码区称为`临界区（Critical Sections）`，临界区需要被以某种互斥机制加以保护，比如`中断屏蔽`、`原子操作`、`自旋锁`、`信号量`、`互斥信号量`等。

### 8.2 中断屏蔽

在单核情况下避免竞态的一种方法是在进入临界区之前屏蔽系统中断，但是多核情况下不适合，中断屏蔽使得中断与进程间的并发不再发生。对于ARM处理器来说，中断屏蔽就是将CPSR寄存器的I位屏蔽。

### 8.3 原子操作

原子操作保证对一个数据的修改是排他性的，Linux内核提供了一系列的原子操作函数，有针对整型变量的和针对位的操作。原子变量的类型为`atomic_t`。`atomic_inc()`、`atomic_add()`等。

### 8.4 自旋锁

为了获取一个自旋锁，在某个CPU上运行的代码需先执行一个原子操作，该操作测试并设置某个内存变量，由于其是原子操作，故操作完成之前其他执行单元不能访问该内存变量。若测试结果表明锁空闲，则程序获得自旋锁，若锁仍然被占用则该程序循环执行测试锁的操作，也就是`自旋`。

自旋锁主要针对SMP或者单核可抢占的情况，对于单核不可抢占的情况，自旋锁退化为空操作。在SMP情况下，任意一个核拿到自旋锁，则该核上的抢占调度就禁止了，但其他核的抢占调度并未禁止。

只有在占用锁时间特别短的情况下，使用自旋锁才是合理的，否则长时间占用会降低系统性能。若递归使用自旋锁，即，一个已经拥有自旋锁的CPU还想获取自旋锁，则会导致该CPU死锁。在自旋锁期间不能使用可能引起进程调度的函数，否则会导致内核崩溃。在中断服务程序中应该调用spin_lock()。

### 8.5 读写锁

解决自旋锁对读写的一视同仁的问题，读写锁保证可以同时读操作，但不能同时写操作，读写操作不能同时进行。`rwlock_t`表示读写锁变量类型，`rwlock_init(rwlock_t *);`初始化读写锁，`read_lock/read_unlock/...`读锁操作，`write_lock/write_unlock/...`写锁操作。

### 8.6 顺序锁

解决读写锁不能同时读写的问题，顺序锁(seqlock)的读写操作可以同时执行，但是写操作之间是互斥的。

### 8.7 读-复制-更新（RCU）

RCU可以直接进行读操作，没有内存屏障、锁等阻塞机制的开销，在写操作时先复制一个副本，对副本进行更改，之后通过回调机制写回原空间。

### 8.8 信号量

P(S)申请操作：

* 将信号量S = S - 1;
* if S >= 0，进程继续执行，否则进程设置为等待状态，进入等待队列

V(S)释放操作：

* S = S + 1;
* if S > 0，唤醒等待队列中的进程。

信号量通常用于同步操作之间，互斥情况下应使用互斥信号量。

### 8.9 互斥信号量

互斥信号量是为了解决优先级翻转的问题，优先级翻转是实时系统中常见的问题，仅存在于基于优先级的抢占式内核中，互斥信号量的取值只有0和1两种。互斥信号量是进程级别的，其实现依赖于自旋锁，当进程占用资源时间较长时应使用mutex。互斥信号量的临界区可以阻塞，但自旋锁绝对不允许。

[@top](#嵌入式面试知识点汇总)

## 九、中断上下文与进程上下文

### 9.1 进程上下文

`进程上文`：其是指进程由用户态切换到内核态是需要保存用户态时cpu寄存器中的值，进程状态以及堆栈上的内容，即保存当前进程的进程上下文，以便再次执行该进程时，能够恢复切换时的状态，继续执行。

`进程下文`：其是指切换到内核态后执行的程序，即进程运行在内核空间的部分。

### 9.2 中断上下文

`中断上文`：硬件通过中断触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理。中断上文可以看作就是硬件传递过来的这些参数和内核需要保存的一些其他环境（主要是当前被中断的进程环境。

`中断下文`：执行在内核空间的中断服务程序。`中断上下文和特定进程无关`。

### 9.3 中断上下文代码中注意事项

* `睡眠或者放弃CPU。`由于中断上下文不属于任何进程，它与current没有任何关系（尽管此时current指向被中断的进程），所以中断上下文一旦睡眠或者放弃CPU，将无法被唤醒。所以也叫原子上下文（atomic context）。`中断服务子程序一定不能睡眠（或者阻塞）。`
* `尝试获得信号量。`为了保护中断句柄临界区资源，不能使用mutexes。如果获得不到信号量，代码就会睡眠，会产生和上面相同的情况，如果必须使用锁，则使用spinlock。
* `执行耗时的任务。`中断处理应该尽可能快，因为内核要响应大量服务和请求，中断上下文占用CPU时间太长会严重影响系统功能。在中断处理例程中执行耗时任务时，应该交由中断处理例程底半部来处理。
* `访问用户空间的虚拟地址。`因为中断上下文是和特定进程无关的，它是内核代表硬件运行在内核空间，所以在终端上下文无法访问用户空间的虚拟地址。
* `中断处理例程不应该设置成reentrant（可被并行或递归调用的例程）。`因为中断发生时，preempt和irq都被disable，直到中断返回。所以中断上下文和进程上下文不一样，中断处理例程的不同实例，是不允许在SMP上并发运行的。
* `中断处理例程可以被更高级别的IRQ中断。`如果想禁止这种中断，可以将中断处理例程定义成快速处理例程，相当于告诉CPU，该例程运行时，禁止本地CPU上所有中断请求。这直接导致的结果是，由于其他中断被延迟响应，系统性能下降。

[@top](#嵌入式面试知识点汇总)

## 十、Linux中断机制

Linux将中断处理程序分解为两个半部：`顶半部（Top Half）`与`底半部（Bottom Half）`。

`顶半部`用于完成尽量少的比较紧急的功能，其往往只是简单的读取寄存器中的中断状态，并在清除中断标志位后进行“登记中断”的操作，“登记中断”意味着将底半部处理程序挂到底半部执行队列中，这样，顶半部执行的速度很快，从而可以服务更多的中断请求。

底半部用来完成中断事件的绝大部分内容，其可以被新的中断打断，其相对来说并不是非常紧急的，而且相对耗时，故不再硬件中断服务程序中执行。

若中断本身的工作很少，完全可以不需要底半部，只在顶半部执行。

### 10.1 底半部机制

Linux实现底半部的机制主要有`tasklet`、`工作队列`、`软中断`和`线程化irq`。

#### 10.1.1 tasklet

tasklet的执行上下文是软中断，执行时机通常是顶半部返回的时候，秩序定义tasklet及其处理函数，并将二者关联即可。

```c
void xxx_do_tasklet(unsigned long);

//定义名称为xxx_tasklet的tasklet，并与xxx_do_tasklet处理函数绑定。
DECLARE_TASKLET(xxx_tasklet, xxx_do_tasklet, 0);

/* 中断底半部 */
void xxx_do_tasklet(unsigned long)
{
    ...
}

/* 中断顶半部 */
irqreturn_t xxx_interrupt(int irq, void *dev_id)
{
    ...
    tasklet_schedule(&xxx_tasklet);//在适当的时候进行调度运行tasklet
    ...
}

/* 设备驱动模块加载函数 */
int __init xxx_init(void)
{
    ...
    /* 申请中断 */
    result = request_irq(xxx_irq, xxx_interrupt, 0, "xxx", NULL);
    ...

    return IRQ_HANDLED;
}

/* 设备驱动模块卸载函数 */
void __exit xxx_exit(void)
{
    ...
    /* 释放中断 */
    free_irq(xxx_irq, xxx_interrupt);
    ...
}

```

#### 10.1.2 工作队列

工作队列的执行上下文是内核线程，因此可以调度和睡眠。

```c
/* 定义工作队列和关联函数 */
struct work_struct xxx_wq;
void xxx_do_work(struct work_struct *work);

/* 中断底半部 */
void xxx_do_work(struct work_struct *work)
{
    ...
}

/* 中断顶半部 */
irqreturn_t xxx_interrupt(int irq, void *dev_id)
{
    ...
    schedule_work(&xxx_wq);
    ...
    return IRQ_HANDLED;
}

/* 驱动加载函数 */
int __init xxx_init(void)
{
    ...
    /* 申请中断 */
    result = request_irq(xxx_irq, xxx_interrupt, 0, "xxx", NULL);
    ...

    /* 初始化工作队列 */
    INIT_WORK(&xxx_wq, xxx_do_work);
    ...
}

/* 模块卸载函数释放中断 */
...
```

#### 10.1.3 软中断

软中断和tasklet运行于软中断上下文，依然属于原子上下文，工作队列运行于进程上下文，故在软中断和tasklet处理函数中不允许睡眠，而在工作队列处理函数中允许睡眠。

#### 10.1.4 线程化irq（threaded_irq）

在内核中除了可以通过request_irq()、devm_request_irq()申请中断外，还可以通过下列两个函数申请中断：

```c
int request_threaded_irq(unsigned int irq, irq_handler_t handler,
                        irq_handler_t thread_fn,
                        unsigned long flags, const char *name, void *dev);
int devm_request_threaded_irq(struct device *dev, unsigned int irq,
                            irq_handler_t handler, irq_handler_t thread_fn,
                            unsigned long irqflags, const char *devname,
                            void *dev_id);
```

在用上述两个API申请中断时，内核会为每个中断号分配一个内核线程`thread_fn`，内核线程调度thread_fn对应的执行函数。

[@top](#嵌入式面试知识点汇总)

## 十一、无线音乐播放系统项目

系统包括上位机与下位机，上位机通过JAVA编写，通过串口通信发送经过采样的WAV格式音乐数据给下位机主控板，由主控板通过NRF24L01无线模块将音乐数据流转发给从控板，从控板连接扬声器及1026显示屏，将音乐数据流实时播放，1602液晶显示当前播放的音乐信息。

### 11.1 WAV格式文件

WAV格式通常用来保存PCM（脉冲编码调制）格式的原始音频数据。PCM文件就是AD转换后得到的二进制数据文件，将PCM加上文件头和文件尾就成了WAV文件。44100HZ 16bit stereo: 每秒钟有 44100 次采样, 采样数据用 16 位(2字节)记录, 双声道(立体声);22050HZ 8bit  mono: 每秒钟有 22050 次采样, 采样数据用 8 位(1字节)记录, 单声道;人对频率的识别范围是 20HZ - 20000HZ, 如果每秒钟能对声音做 20000 个采样, 回放时就足可以满足人耳的需求. 所以 22050 的采样频率是常用的。1 字节(也就是8bit) 只能记录 256 个数, 也就是只能将振幅划分成 256 个等级;

### 11.2 PWM驱动音响播放过程

PWM信号可看作一个直流信号与锯齿波比较得到的信号，其占空比反映了直流信号的大小，所以PWM经低通滤波之后可以恢复直流信号，直流信号的大小由占空比决定。PWM做音频输出时，其频率是固定的（这个频率决定声调，一般的语音信号取11.025kHz。），然后将PCM文件中的数据作为占空比大小输出PWM波，经低通滤波后驱动扬声器即可得到声音。

由于使用用D/A转换器实现模拟量的输出成本较高，音质效果也不佳。项目所选用的STC15F2K60S2单片机用过PCA通道调制8位的PWM信号，还原8位单声道的WAV声音文件。

我们采用的是8位单声道，采样频率为12200Hz的采样文件，与串口波特率115200相结合，进行音乐播放。

设置定时器的输出频率为WAV文件的采样频率就可以对原WAV格式的文件进行还原，定时器0的工作在16位自动重装载模式下，且工作在1T（不分频）模式时，定时器的输出频率为：

$f_{pwm} = sysclk \div (65536 - [RL\_TH0, RL\_TL0])\div2$

故设置定时器的自动重装载值为：

$[RL\_TH0, RL\_TL0] = 65536 - sysclk \div (f_{pwm} \times 2)$

[@top](#嵌入式面试知识点汇总)

## 十二、Linux系统启动流程

以x86体系结构为例，Linux的上电启动大致分为五个过程：`史前时期：BIOS`、`远古时代：引导装入程序（bootloader）`、`中世纪：setup()函数`、`文艺复兴时期：startup_32()函数`、`现代：start_kernel()`。

### 12.1 史前时期：BIOS

计算机在上电的瞬间其RAM芯片中包含的是随机数据，此时还没有操作系统在运行，在开始启动时，复位电路在CPU的复位引脚产生复位信号（RESET）。复位信号产生后将CPU的某些寄存器设置为固定值，并执行在物理地址0xfffffff0处的代码，硬件将该地址映射到ROM中，ROM中存放的是系统的BIOS。

BIOS在实模式下运行，其直接使用的物理内存的实际物理地址，其地址由`段地址+偏移量`组成。

BIOS的启动主要包含四个操作：

* 上电自检（POST）：对计算机硬件进行测试，检测有哪些设备，显示一些版本信息等。
* 初始化硬件设备。
* 搜索一个操作系统用来启动。
* 只要找到一个有效设备，就将该设备第一个扇区的内容拷贝到RAM中开始执行。

### 12.2 远古时代：引导装入程序（bootloader）

bootloader是由BIOS用来将Linux内核映像装载到RAM中所调用的一个程序。硬盘的第一个扇区称为主引导记录（MBR），该扇区中包含分区表和一个用来装载被启动的操作系统所在分区的第一个扇区。

bootloader将内核映像或相应的引导扇区拷贝到RAM中，之后跳转到setup()代码处。

### 12.3 中世纪：setup()函数

setup()函数初始化计算机的硬件设备，并为内核程序的执行建立环境，虽然BIOS已经初始化了大部分硬件设备，但Linux不依赖于BIOS，需要以自己的方式重新初始化。

setup()的操作中重要的是建立了临时中断描述符表与临时全局描述符表，并且将CPU`从实模式切换到保护模式`，之后跳转到`arch/i386/boot/compressed/head.S`文件下的`startup_32()`汇编函数处。

### 12.4 文艺复兴时期：startup_32()函数

有两个head.S文件，每个head.S中都包含一个startup_32()函数，在setup()执行完成后，`arch/i386/boot/compressed/head.S`文件下的`startup_32()`被移动到物理地址的0x00100000或0x00001000处，取决于内核映像是`高装载`还是`低装载`。

该函数主要执行以下功能：

* 1、初始化段寄存器；
* 2、清零eflags寄存器的所有位；
* 3、用0填充内核未初始化的数据区；
* 4、调用decompress_kernel()函数解压内核映像，若低装载，解压后存放在0x00001000内存处，高装载，解压后存放在临时内存区，之后移动到0x00100000处。
* 5、跳转到解压后的内存地址处。

解压后的内核包含`arch/i386/kernel/head.S`中的另一个startup_32()函数。这两个函数不会冲突，应为在不同的内存地址。

第二个startup_32()函数为Linux的0进程建立执行环境。并跳转到`start_kernel()`函数处。

### 12.5 现代：start_kernel()

start_kernel()函数完成Linux内核的初始化工作：

* 调用sched_init()函数初始化调度程序；
* 初始化内存管理区；
* 初始化buddy系统分配程序；
* 完成全局中断向量表的初始化；
* 初始化tasklet与softirq；
* 初始化系统日期与时间；
* 初始化slab分配器；
* 确定cpu时钟速度；
* 调用kernel_thread()函数为进程1创建内核线程，该内核线程又会创建其他内核线程并执行`/sbin/init`程序。

之后通知用户Linux启动完毕，显示命令提示符。

[@top](#嵌入式面试知识点汇总)

## 十三、硬件高速缓存（Cache）

为了缩小CPU与RAM之间的速度不匹配，引入了硬件高速缓存，硬件告诉缓存基于局部性原理，使用LRU（最近最少使用）算法。80x86引入cache line的单位，cache line由几十个连续的字节组成，以burst mode（突发模式）在慢速DRAM（内存）与高速SRAM（cache）之间传送数据，实现高速缓存。

### 13.1 Burst Mode 突发模式

所谓的“突发”是指当我们对一个地址进行寻址并操作完成后，不必再重新对下一个地址进行寻址，而是直接进行操作。这样就节省了很多的时间。

* 读：初始化→发行地址→RCD→发列地址→CL→数据
* 写：初始化→发行地址→RCD→发列地址→数据

### 13.2 高速缓存结构

高速缓存单元插在分页单元与内存之间。其包含一个硬件高速缓存内存（hardware cache memory）和一个高速缓存控制器（cache controller）。高速缓存内存中存放内存（DRAM）中真正的行（line）。高速缓存控制器存放一个表项数组，数组中的每个表项对应高速缓存中的一个cache line。cache controler中的每个cache line有一个标签（tag）和几个状态标志（flag）。其中标签（tag）由若干位（bit）组成，这些bit让cache controler能够分辨出该cache line当前所映射的内存（DRAM）单元。

内存的物理地址被分为3份，高几位对应cache line中的tag，中间几位对应cache controler的子集索引，低几位对应cache line的偏移量。

### 13.3 cache命中

当访问一个内存（DRAM）单元时，CPU从物理地址中提取出子集的索引号并把子集中所有的cache line的tag与物理地址的高几位比较，若有某一行的tag与物理地址高几位相同，则代表CPU `cache命中`，否则`cache未命中`。

### 13.4 写通与写回

* 写通（write-through）是指cache controler既写RAM也写cache line。
* 写回（write-back）是指cache controler只更新cache line但不改变RAM中的内容，但是写回结束后更新RAM。

Linux对于所有的页框都启用高速缓存，对于写操作总是采用写回（write back）策略。

[@top](#嵌入式面试知识点汇总)

## 十四、Linux内核空间与用户空间

Linux系统采取两级保护机制，对应两种不同的操作权限，内核空间权限高于用户空间权限，内核空间和用户空间都有属于自己的虚拟空间。

### 14.1 区别

在32位系统中，cpu最高有32位寻址范围，即对应4G空间（未开启PAE分页），内核空间被划分在高1G虚拟空间，用户空间在低3G。

普通应用程序运行在用户空间，执行一些贴近用户的低权限操作，系统内核程序，操作硬件的驱动程序等一些要求高级权限的程序运行在内核空间。

用户空间程序不能直接访问内核空间的数据，内核空间程序也一样不能直接访问属于用户进程空间的数据，用户空间和内核空间之间的通信必须通过一些特定的方法。

### 14.2 用户空间与内核通信方式

#### 14.2.1 系统调用

内核空间提供了用户进程与内核交互的一组接口，叫做`系统调用`。一般情况下，应用程序通过在用户空间实现的应用编程接口（API）而不是直接通过系统调用来编程。例如：应用程序调用c库函数printf()，cku会调用c库中的write()函数，c库中的write()函数会调用系统调用中的write()接口,通过copy_from_user()向内核写入数据。

`系统调用号`：在linux中，每个系统调用被赋予一个系统调用号。当用户空间的进程执行一个系统调用的时候，这个系统调用号就用来指明到底是要执行哪个系统调用。系统调用号相当重要，一旦分配就不能再有任何变更，否则编译好的应用程序就会崩溃；内核记录了系统调用表中的所有已注册的系统调用的列表，存储在sys_call_table中。 如：x86-64中，定义在`arch/i386/kernel/syscall_64.c`。
  
在用户空间可以通过`syscall(__NR_SYSCALL_BASE+系统调用号)`调用指定的系统调用。

#### 14.2.2 虚拟文件系统

* Procfs:/proc 文件系统是一个虚拟文件系统，通过它可以使用一种新的方法在 Linux内核空间和用户间之间进行通信。这些虚拟文件的内容都是动态创建的。其目的是`反映进程的状态信息`。“/proc”下的绝大多数文件都是只读的，以显示内核信息为主，例如显示内存信息`cat /proc/meminfo`。还可用于一定的控制或配置目的。例如：`/proc/sys/kernel/printk`可以改变printk()的打印级别。
* Sysfs：该文件系统是一个虚拟的文件系统，它可以产生一个包括所有系统硬件的层级视图。其目的是`用于显示Linux设备模型`，其顶级目录包括block、bus、dev、devices、class、fs、kernel、prwer和firmware等。
* Debugfs：用于内核调试的虚拟文件系统，因为如果相关的调试接口要在相当长的一段时间内存在于内核之中，就不太适合放在procfs和sysfs里了，debugfs应运而生。默认情况下，debugfs会被挂载在目录/sys/kernel/debug之下。

#### 14.2.3 ioctl接口

一个字符设备驱动通常会实现常规的打开、关闭、读、写等功能，但在一些细分的情境下，如果需要扩展新的功能，通常以增设ioctl()命令的方式实现，其作用类似于“拾遗补漏”。通过定义内核与用户空间都知道的CMD命令参数，在用户空间调用ioctl()函数时，会将CMD命令传入内核空间，内核空间解析CMD命令执行相应的操作。CMD命令可以通过一系列辅助宏生成。

```c
#define _IO(type,nr)        _IOC(_IOC_NONE,(type),(nr),0)
#define _IOR(type,nr,size)  _IOC(_IOC_READ,(type),(nr),sizeof(size))
#define _IOW(type,nr,size)  _IOC(_IOC_WRITE,(type),(nr),sizeof(size))
#define _IOWR(type,nr,size) _IOC(_IOC_READ|_IOC_WRITE,(type),(nr),sizeof(size))
```

* 用户空间：

```c
/*
参数：
fd：文件描述符。
cmd：交互协议，设备驱动将根据cmd执行对应操作。
...:可变参数arg，依赖cmd指定长度以及类型。
返回值：
ioctl()执行成功时返回0，失败则返回-1并设置全局变量errorno值
*/
int ioctl(int fd, int cmd, ...) ;
```

* 内核空间：

```c
static const struct file_operations fops = {
    .owner = THIS_MODULE,
    .open = test_open,
    .release = test_close,
    .read = test_read,
    .write = test_write,
    .unlocked_ioctl = test_ioctl,
};

static long test_ioctl(struct file *file, unsigned int cmd, \
                        unsigned long arg)
{
    switch(cmd) {
    /* 初始化设备 */
    case XXX:
        XXX();
        break;
    ...
}

```

#### 14.2.4 netlink

netlink其实就是一种socket通信，是用于在内核态和用户态进程之间进行数据传输的特殊的IPC。它通过为内核模块提供一组特殊的API，并为用户程序提供了一组标准的socket 接口的方式，实现了一种全双工的通讯连接。类似于TCP/IP中使用AF_INET地址族一样，netlink socket使用地址族AF_NETLINK。每一个netlink socket在内核头文件include/linux/netlink.h中定义自己的协议类型。

在内核空间，我们调用如下的API：

```c
struct sock * netlink_kernel_create(int unit, void (*input)(struct sock *sk, int len));
```

参数uint是netlink协议类型，例如`NETLINK_TEST`。函数指针，input,是netlink socket在收到消息时调用的处理消息的回调函数指针。

在用户空间，应用程序调用`sock_fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_TEST);`创建一个netlink socket与内核进行通信。

[@top](#嵌入式面试知识点汇总)

## 十五、排序算法

![排序时间复杂度统计](https://github.com/jonewan/jonewan/blob/master/Sort/%E6%8E%92%E5%BA%8F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%BB%9F%E8%AE%A1.jpg?raw=true)

[@top](#嵌入式面试知识点汇总)

## 十六、进程间通信

进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。IPC的方式通常有`管道（无名管道）`、`FIFO（有名管道）`、`消息队列`、`信号量`、`共享存储`等。

### 16.1 管道

管道，通常指无名管道，其特点如下：

* 它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。
* 它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）。
* 它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。

```c
#include <unistd.h>
int pipe(int fd[2]);    // 返回值：若成功返回0，失败返回-1
```

当一个管道建立时，它会创建两个文件描述符：fd[0]为读而打开，fd[1]为写而打开。如下图所示。

![管道](https://github.com/jonewan/markdown/blob/master/job_test/%E7%AE%A1%E9%81%93.jpg?raw=true)

要关闭管道只需将这两个文件描述符关闭即可。

单个进程中的管道几乎没有任何用处。所以，通常调用 pipe 的进程接着调用 fork，这样就创建了父进程与子进程之间的 IPC 通道。

若要数据流从父进程流向子进程，则关闭父进程的读端（fd[0]）与子进程的写端（fd[1]）；反之，则可以使数据流从子进程流向父进程。

![管道通信](https://github.com/jonewan/markdown/blob/master/job_test/%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1.jpg?raw=true)

```c
#include<stdio.h>
#include<unistd.h>

int main()
{
    int fd[2];  // 两个文件描述符
    pid_t pid;
    char buff[20];

    if(pipe(fd) < 0)  // 创建管道
        printf("Create Pipe Error!\n");

    if((pid = fork()) < 0)  // 创建子进程
        printf("Fork Error!\n");
    else if(pid > 0)  // 父进程
    {
        close(fd[0]); // 关闭读端
        write(fd[1], "hello world\n", 12);
    }
    else
    {
        close(fd[1]); // 关闭写端
        read(fd[0], buff, 20);
        printf("%s", buff);
    }

    return 0;
}
```

### 16.2 FIFO

FIFO，也称为命名管道，它是一种文件类型。其特点如下：

* FIFO可以在无关的进程之间交换数据，与无名管道不同。
* FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。

```c
#include <sys/stat.h>
// 返回值：成功返回0，出错返回-1
int mkfifo(const char *pathname, mode_t mode);
```

其中的 mode 参数与open函数中的 mode 相同。一旦创建了一个 FIFO，就可以用一般的文件I/O函数操作它。当 open 一个FIFO时，是否设置非阻塞标志（O_NONBLOCK）的区别：

* 若没有指定O_NONBLOCK（默认），只读 open 要阻塞到某个其他进程为写而打开此 FIFO。类似的，只写 open 要阻塞到某个其他进程为读而打开它。
* 若指定了O_NONBLOCK，则只读 open 立即返回。而只写 open 将出错返回 -1 如果没有进程已经为读而打开该 FIFO，其errno置ENXIO。

FIFO的通信方式类似于在进程中使用文件来传输数据，只不过FIFO类型文件同时具有管道的特性。在数据读出时，FIFO管道中同时清除数据，并且“先进先出”。下面的例子演示了使用 FIFO 进行 IPC 的过程：

```c
/*write_fifo.c*/
#include<stdio.h>
#include<stdlib.h>   // exit
#include<fcntl.h>    // O_WRONLY
#include<sys/stat.h>
#include<time.h>     // time

int main()
{
    int fd;
    int n, i;
    char buf[1024];
    time_t tp;

    printf("I am %d process.\n", getpid()); // 说明进程ID
    if((fd = open("fifo1", O_WRONLY)) < 0) // 以写打开一个FIFO
    {
        perror("Open FIFO Failed");
        exit(1);
    }

    for(i=0; i<10; ++i)
    {
        time(&tp);  // 取系统当前时间
        n=sprintf(buf,"Process %d's time is %s",getpid(),ctime(&tp));
        printf("Send message: %s", buf); // 打印
        if(write(fd, buf, n+1) < 0)  // 写入到FIFO中
        {
            perror("Write FIFO Failed");
            close(fd);
            exit(1);
        }
        sleep(1);  // 休眠1秒
    }

    close(fd);  // 关闭FIFO文件
    return 0;
}

/*read_fifo.c*/
#include<stdio.h>
#include<stdlib.h>
#include<errno.h>
#include<fcntl.h>
#include<sys/stat.h>

int main()
{
    int fd;
    int len;
    char buf[1024];

    if(mkfifo("fifo1", 0666) < 0 && errno!=EEXIST) // 创建FIFO管道
        perror("Create FIFO Failed");

    if((fd = open("fifo1", O_RDONLY)) < 0)  // 以读打开FIFO
    {
        perror("Open FIFO Failed");
        exit(1);
    }

    while((len = read(fd, buf, 1024)) > 0) // 读取FIFO管道
        printf("Read message: %s", buf);

    close(fd);  // 关闭FIFO文件
    return 0;
}
```

### 16.3 消息队列

消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。消息队列的特点如下：

* 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。
* 消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。
* 消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。

```c
#include <sys/msg.h>
// 创建或打开消息队列：成功返回队列ID，失败返回-1
int msgget(key_t key, int flag);
// 添加消息：成功返回0，失败返回-1
int msgsnd(int msqid, const void *ptr, size_t size, int flag);
// 读取消息：成功返回消息数据的长度，失败返回-1
int msgrcv(int msqid, void *ptr, size_t size, long type,int flag);
// 控制消息队列：成功返回0，失败返回-1
int msgctl(int msqid, int cmd, struct msqid_ds *buf);
```

### 16.4 信号量

信号量（semaphore）是一个计数器，用于实现进程间的同步，而不是用于存储进程间通信数据。其特点如下：

* 信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。
* 信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。
* 每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。
* 支持信号量组。

### 16.5 共享内存

共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区。共享内存的特点：

* 共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。
* 因为多个进程可以同时操作，所以需要进行同步。
* 信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。

### 16.6 总结

* 管道：速度慢，容量有限，只有父子进程能通讯。
* FIFO：任何进程间都能通讯，但速度慢。
* 消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。
* 信号量：不能传递复杂消息，只能用来同步。
* 共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存。

[@top](#嵌入式面试知识点汇总)
