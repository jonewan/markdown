<!DOCTYPE html>
    <html>
    <head>
        <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
        <title>嵌入式面试知识点汇总</title>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        <link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
    </head>
    <body>
        <h1 id="%e5%b5%8c%e5%85%a5%e5%bc%8f%e9%9d%a2%e8%af%95%e7%9f%a5%e8%af%86%e7%82%b9%e6%b1%87%e6%80%bb">嵌入式面试知识点汇总</h1>
<h2 id="%e4%b8%80c%e8%af%ad%e8%a8%80static%e5%85%b3%e9%94%ae%e5%ad%97">一、C语言static关键字</h2>
<p>一般程序把动态数据存放在堆区，局部变量存放在栈区。局部变量一般会随着函数的退出而释放空间，全局变量、静态数据、常量都在全局数据区（静态存储区）在编译时分配内存，程序结束后由系统释放。</p>
<h3 id="11-%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f">1.1 全局变量</h3>
<p>全局变量在全局数据区分配内存，未经初始化的全局变量会被程序自动初始化为0。</p>
<p>未加static修饰的全局变量默认是有外部链接的，作用域是整个工程，在一个文件中定义的全局变量，在另一个文件中可以通过<code>extern</code>全局变量的声明引用该变量。</p>
<p>用static修饰的全局变量，作用域是该文件中，其他文件即使使用<code>extern</code>关键字也不能访问。</p>
<h3 id="12-%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f">1.2 局部变量</h3>
<p>局部变量不加<code>static</code>修饰符默认是<code>auto</code>修饰的。程序为局部变量在栈区分配内存，函数退出后系统回收栈区空间，释放局部变量。</p>
<p><code>static</code>修饰的局部变量叫做<code>静态局部变量</code>，其在全局数据区（静态存储区）在编译时分配空间，变量的作用域依然只是函数体内，但变量的生命周期从程序运行开始到程序运行结束。</p>
<h3 id="13-%e5%87%bd%e6%95%b0">1.3 函数</h3>
<p><code>static</code>修饰的函数表明该函数只在本文件内可见，不能被其他文件在外部调用，因此在多文件编译时可以在不同文件中定义相同名称的静态函数而不会引发编译冲突。</p>
<h2 id="%e4%ba%8c%e7%bb%93%e6%9e%84%e4%bd%93%e4%b8%8e%e5%85%b1%e7%94%a8%e4%bd%93">二、结构体与共用体</h2>
<p>结构体的定义本身仅仅是一个“设计/蓝图”，其并不占用任何存储空间，当其实例化之后，实例才是真正占用的内存空间。</p>
<p>结构体的长度的简单计算结果是所有成员长度之和（1=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">2^{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>字节对齐模式）。</p>
<ul>
<li>注：若使用其他字节对齐模式的话，其空间长度的计算需要按照字节对齐模式相应改变。</li>
</ul>
<p>共用体的诸成员共同使用同一起始空间，共用体的长度是共用体中成员的最大长度成员的长度。</p>
<h3 id="21-%e5%ad%97%e8%8a%82%e5%af%b9%e9%bd%90%e6%a8%a1%e5%bc%8f">2.1 字节对齐模式</h3>
<p><code>struct{...}__align(num)</code>用来指定字节对齐模式，按照num字节来对齐，num为2的整数次幂。<code>__packed</code>是进行一字节对齐</p>
<h2 id="%e4%b8%89arm%e6%9e%b6%e6%9e%84%e4%b8%8ex86%e6%9e%b6%e6%9e%84">三、ARM架构与x86架构</h2>
<p><code>ARM(Advanced RSCI Mechine)</code>，其采用<code>RISC(Reduced Instruction Set Computers，精简指令集计算集)</code>。ARM处理器本身定位于嵌入式平台，应付轻量级、目的单一明确的程序。</p>
<p><code>x86</code>定位于桌面和服务器，这些平台上很多应用是计算密集型的，比如多媒体编辑、科研计算、模拟等等。其采用<code>CISC(Complex Instruction Set Computers，复杂指令集计算集)</code>。</p>
<h3 id="31-risc%e4%b8%8ecisc%e7%9a%84%e5%8c%ba%e5%88%ab">3.1 RISC与CISC的区别</h3>
<ul>
<li>指令系统：RISC 设计者把主要精力放在那些经常使用的指令上，尽量使它们具有简单高效的特色。对不常用的功能，常通过组合指令来完成。</li>
<li>存储器操作：RISC 对存储器操作有限制，使控制简单化；而CISC 机器的存储器操作指令多，操作直接。</li>
<li>程序：RISC 汇编语言程序一般需要较大的内存空间，实现特殊功能时程序复杂，不易设计；而CISC 汇编语言程序编程相对简单，科学计算及复杂操作的程序设计相对容易，效率较高。</li>
<li>中断：RISC 机器在一条指令执行的适当地方可以响应中断；而CISC 机器是在一条指令执行结束后响应中断。</li>
<li>CPU芯片电路：RISC CPU 包含有较少的单元电路，因而面积小、功耗低；而CISC CPU 包含有丰富的电路单元，因而功能强、面积大、功耗大。</li>
<li>设计周期：RISC 微处理器结构简单，布局紧凑，设计周期短，且易于采用最新技术；CISC 微处理器结构复杂，设计周期长。</li>
<li>用户使用：RISC 微处理器结构简单，指令规整，性能容易把握，易学易用；CISC微处理器结构复杂，功能强大，实现特殊功能容易。</li>
<li>应用范围：由于RISC 指令系统的确定与特定的应用领域有关，故RISC 机器更适合于专用机；而CISC 机器则更适合于通用机。</li>
</ul>
<p>目前常见使用RISC的处理器包括DEC Alpha、ARC、<code>ARM</code>、<code>MIPS</code>、<code>PowerPC</code>、SPARC和SuperH等。常见使用CISC的处理器主要有<code>X86</code>。</p>
<h2 id="%e5%9b%9b%e9%80%9a%e4%bf%a1%e5%8d%8f%e8%ae%ae">四、通信协议</h2>
<p>根据数据的传输方向，通信协议分为<code>单工通信</code>、<code>半双工通信</code>与<code>全双工通信</code>。</p>
<ul>
<li>单工通信：在通信过程的任意时刻,信息只能由一方A传到另一方B。</li>
<li>半双工通信：在任意时刻,信息既可由A传到B,又能由B传A,但同一时刻智能存在一个方向。</li>
<li>全双工通信：在任意时刻,线路上存在A到B和B到A的双向信号传输。</li>
</ul>
<h2 id="%e4%ba%94%e5%ad%97%e8%8a%82%e5%ad%98%e5%82%a8%e6%a8%a1%e5%bc%8f">五、字节存储模式</h2>
<p>在计算机中我们是以字节为单位进行存储的，每个地址单元对应一个字节，由于一个寄存器的宽度大于等于一个字节，因此必然存在着如何将多个字节安排的问题，故出现了<code>大端（Big-Endian）</code>与<code>小端（Little-Endian）</code>存储模式。***大小端存储模式是由CPU架构决定的，不是由操作系统决定的。***在Linux中<code>/usr/include/elf.h</code>文件定义了不同处理器的大小端模式。Windows中<code>C:\Program Files (x86)\Windows Kits\8.1\Include\um\winnt.h</code>定义了不同处理器的大小端模式。</p>
<ul>
<li>大端（Big-Endian）：通俗来讲就是<code>高低低高</code>，即，高字节存储在低端内存区域，低字节存储在高端内存区域。</li>
<li>小端（Little-Endian）：通俗来讲就是<code>高高低低</code>，即，高字节存储在高端内存区域，低字节存储在低端内存区域。</li>
</ul>
<p><code>通常一个数据的最左侧为高端字节，最右侧为低端字节。</code></p>
<p>用一张图来表示：</p>
<p><img src="https://raw.githubusercontent.com/jonewan/markdown/master/job_test/%E5%AD%97%E8%8A%82%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F.bmp" alt="大小端存储"></p>
<p>大小端在网络通信中最常使用，在利用socket编程时会使用如下的宏：</p>
<pre><code class="language-c"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ntohs(n) <span class="hljs-comment">//16位数据类型网络字节顺序到主机字节顺序的转换</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> htons(n) <span class="hljs-comment">//16位数据类型主机字节顺序到网络字节顺序的转换</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ntohl(n) <span class="hljs-comment">//32位数据类型网络字节顺序到主机字节顺序的转换</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> htonl(n) <span class="hljs-comment">//32位数据类型主机字节顺序到网络字节顺序的转换</span></span>
</div></code></pre>
<p>其中互联网使用的网络字节顺序采用大端模式进行编址，而主机字节顺序根据处理器的不同而不同，x86系统用的是小端（Little-endian）存储，而powerPC采用的是大端（Big-endian）存储。</p>
<p>在计算机的数据传输中，传输的通常是一个一个位（bit），在这些位数据中如何准确解析数据呢？就通过<code>最高有效位（Most Significant Bit,MSB）</code>与<code>最低有效位（Least Significant Bit,LSB）</code>来确定。<code>最高有效位（MSB）</code>指的是一个二进制中最高位的比特，相反，<code>最低有效位（LSB）</code>指的是一个二进制中最低位的比特。比如串口发送数据时是LSB先发送，而MSB后发送。在计算机的一个字节（8bit）中，LSB是最右边的位，MSB是最左边的位。</p>
<h2 id="%e5%85%adarm%e6%8c%87%e4%bb%a4%e5%92%8cthumb%e6%8c%87%e4%bb%a4">六、ARM指令和Thumb指令</h2>
<p>在ARM的体系结构中，可以工作在三种不同的状态，一是ARM状态，二是Thumb状态及Thumb-2状态，三是调试状态。而ARM状态和Thumb状态可以直接通过某些指令直接切换，都是在运行程序，只不过指令长度不一样而已。</p>
<ul>
<li>ARM状态：arm处理器工作于32位指令的状态，所有指令均为32位；</li>
<li>Thumb状态：arm执行16位指令的状态，即16位状态；</li>
<li>thumb-2状态：这个状态是ARM7版本的ARM处理器所具有的新的状态，新的thumb-2内核技术兼有16位及32位指令，实现了更高的性能，更有效的功耗及更少地占用内存。总的来说，感觉这个状态除了兼有arm和thumb的优点外，还在这两种状态上有所提升，优化；</li>
<li>调试状态：处理器停机时进入调试状态。</li>
</ul>
<h3 id="61-arm%e7%8a%b6%e6%80%81%e5%92%8cthumb%e7%8a%b6%e6%80%81%e5%88%87%e6%8d%a2%e7%a8%8b%e5%ba%8f">6.1 ARM状态和Thumb状态切换程序</h3>
<ul>
<li>从ARM到Thumb: <code>LDR R0,=lable+1 BX R0</code>（状态将寄存器的最低位设置为1，BX指令、R0指令将进入thumb状态）；</li>
<li>从ARM到Thumb: <code>LDR R0,=lable BX R0</code>（寄存器最低位设置为0，BX指令、R0指令将进入arm状态）。</li>
<li>当处理器进行异常处理时，则从异常向量地址开始执行，将自动进入ARM状态。</li>
</ul>
<h2 id="%e4%b8%83%e5%8d%95%e7%89%87%e6%9c%ba%e7%9a%84%e5%bc%80%e6%bc%8f%e8%be%93%e5%87%ba%e4%b8%8e%e6%8e%a8%e6%8c%bd%e8%be%93%e5%87%ba%e7%9a%84%e5%8c%ba%e5%88%ab">七、单片机的开漏输出与推挽输出的区别</h2>
<p>推挽输出:可以输出高,低电平,连接数字器件。</p>
<ul>
<li>输出 0 时，N-MOS 导通，P-MOS 高阻，输出0。</li>
<li>输出 1 时，N-MOS 高阻，P-MOS 导通，输出1（不需要外部上拉电路）。</li>
</ul>
<p>开漏输出:输出端相当于三极管的集电极. 要得到高电平状态需要上拉电阻才行. 适合于做电流型的驱动,其吸收电流的能力相对强(一般20ma以内)。</p>
<ul>
<li>输出 0 时，N-MOS 导通，P-MOS 不被激活，输出0。</li>
<li>输出 1 时，N-MOS 高阻， P-MOS 不被激活，输出1（需要外部上拉电路）；可以读IO输入电平变化，此模式可以把端口作为双向IO使用。</li>
</ul>
<h2 id="%e5%85%ablinux%e4%b8%ad%e7%9a%84%e5%b9%b6%e5%8f%91%e6%8e%a7%e5%88%b6%e9%94%81%e6%9c%ba%e5%88%b6">八、Linux中的并发控制（锁机制）</h2>
<h3 id="81-linux%e5%86%85%e6%a0%b8%e7%9a%84%e7%ab%9e%e6%80%81%e5%8f%91%e7%94%9f%e7%9a%84%e6%83%85%e5%86%b5">8.1 Linux内核的竞态发生的情况</h3>
<h4 id="811-%e5%af%b9%e7%a7%b0%e5%a4%9a%e5%a4%84%e7%90%86%e5%99%a8smp%e7%9a%84%e5%a4%9a%e4%b8%aacpu%e9%97%b4">8.1.1 对称多处理器（SMP）的多个CPU间</h4>
<p>SMP是一种多个CPU使用共同的系统总线访问共同的外设和存储器的系统模型。在这种情况下，竞态可能发生在两个CPU的进程之间、中断之间、进程与中断之间。</p>
<h4 id="812-%e5%8d%95%e6%a0%b8%e8%bf%9b%e7%a8%8b%e4%b8%8e%e5%85%b6%e6%8a%a2%e5%8d%a0%e8%bf%9b%e7%a8%8b%e9%97%b4">8.1.2 单核进程与其抢占进程间</h4>
<p>一个进程在内核态执行时消耗完自己的时间片或者被其他高优先级的进程抢占。</p>
<h4 id="813-%e4%b8%ad%e6%96%ad%e4%b8%8e%e8%bf%9b%e7%a8%8b%e4%b9%8b%e9%97%b4">8.1.3 中断与进程之间</h4>
<p>若中断服务程序访问进程正在访问的资源，就会产生竞态。中断嵌套也有可能导致竞态。</p>
<p>访问共享资源的代码区称为<code>临界区（Critical Sections）</code>，临界区需要被以某种互斥基址加以保护，比如<code>中断屏蔽</code>、<code>原子操作</code>、<code>自旋锁</code>、<code>信号量</code>、<code>互斥信号量</code>等。</p>
<h3 id="82-%e4%b8%ad%e6%96%ad%e5%b1%8f%e8%94%bd">8.2 中断屏蔽</h3>
<p>在单核情况下避免竞态的一种方法是在进入临界区之前屏蔽系统中断，但是多核情况下不适合，中断屏蔽使得中断与进程间的并发不再发生。对于ARM处理器来说，中断屏蔽就是将CPSR寄存器的I位屏蔽。</p>
<h3 id="83-%e5%8e%9f%e5%ad%90%e6%93%8d%e4%bd%9c">8.3 原子操作</h3>
<p>原子操作保证对一个数据的修改是排他性的，Linux内核提供了一系列的原子操作函数，有针对整型变量的和针对位的操作。原子变量的类型为<code>atomic_t</code>。<code>atomic_inc()</code>、<code>atomic_add()</code>等。</p>
<h3 id="84-%e8%87%aa%e6%97%8b%e9%94%81">8.4 自旋锁</h3>
<p>为了获取一个自旋锁，在某个CPU上运行的代码需先执行一个原子操作，该操作测试并设置某个内存变量，由于其是原子操作，故操作完成之前其他执行单元不能访问该内存变量。若测试结果表明锁空闲，则程序获得自旋锁，若锁仍然被占用则该程序循环执行测试锁的操作，也就是<code>自旋</code>。</p>
<p>自旋锁主要针对SMP或者单核可抢占的情况，对于单核不可抢占的情况，自旋锁退化为空操作。在SMP情况下，任意一个核拿到自旋锁，则该核上的抢占调度就禁止了，但其他核的抢占调度并未禁止。</p>
<p>只有在占用锁时间特别短的情况下，使用自旋锁才是合理的，否则长时间占用会降低系统性能。若递归使用自旋锁，即，一个已经拥有自旋锁的CPU还想获取自旋锁，则会导致该CPU死锁。在自旋锁期间不能使用可能引起进程调度的函数，否则会导致内核崩溃。在中断服务程序中应该调用spin_lock()。</p>
<h3 id="85-%e8%af%bb%e5%86%99%e9%94%81">8.5 读写锁</h3>
<p>解决自旋锁对读写的一视同仁的问题，读写锁保证可以同时读操作，但不能同时写操作，读写操作不能同时进行。<code>rwlock_t</code>表示读写锁变量类型，<code>rwlock_init(rwlock_t *);</code>初始化读写锁，<code>read_lock/read_unlock/...</code>读锁操作，<code>write_lock/write_unlock/...</code>写锁操作。</p>
<h3 id="86-%e9%a1%ba%e5%ba%8f%e9%94%81">8.6 顺序锁</h3>
<p>解决读写锁不能同时读写的问题，顺序锁(seqlock)的读写操作可以同时执行，但是写操作之间是互斥的。</p>
<h3 id="87-%e8%af%bb-%e5%a4%8d%e5%88%b6-%e6%9b%b4%e6%96%b0rcu">8.7 读-复制-更新（RCU）</h3>
<p>RCU可以直接进行读操作，没有内存屏障、锁等阻塞机制的开销，在写操作时先复制一个副本，对副本进行更改，之后通过回调机制写回原空间。</p>
<h3 id="88-%e4%bf%a1%e5%8f%b7%e9%87%8f">8.8 信号量</h3>
<p>P(S)申请操作：</p>
<ul>
<li>将信号量S = S - 1;</li>
<li>if S &gt;= 0，进程继续执行，否则进程设置为等待状态，进入等待队列</li>
</ul>
<p>V(S)释放操作：</p>
<ul>
<li>S = S + 1;</li>
<li>if S &gt; 0，唤醒等待队列中的进程。</li>
</ul>
<p>信号量通常用于同步操作之间，互斥情况下应使用互斥信号量。</p>
<h3 id="89-%e4%ba%92%e6%96%a5%e4%bf%a1%e5%8f%b7%e9%87%8f">8.9 互斥信号量</h3>
<p>互斥信号量是为了解决优先级翻转的问题，互斥信号量是进程级别的，其实现依赖于自旋锁，当进程占用资源时间较长时应使用mutex。互斥信号量的临界区可以阻塞，但自旋锁绝对不允许。</p>
<h2 id="%e4%b9%9d%e4%b8%ad%e6%96%ad%e4%b8%8a%e4%b8%8b%e6%96%87%e4%b8%8e%e8%bf%9b%e7%a8%8b%e4%b8%8a%e4%b8%8b%e6%96%87">九、中断上下文与进程上下文</h2>
<h3 id="91-%e8%bf%9b%e7%a8%8b%e4%b8%8a%e4%b8%8b%e6%96%87">9.1 进程上下文</h3>
<p><code>进程上文</code>：其是指进程由用户态切换到内核态是需要保存用户态时cpu寄存器中的值，进程状态以及堆栈上的内容，即保存当前进程的进程上下文，以便再次执行该进程时，能够恢复切换时的状态，继续执行。</p>
<p><code>进程下文</code>：其是指切换到内核态后执行的程序，即进程运行在内核空间的部分。</p>
<h3 id="92-%e4%b8%ad%e6%96%ad%e4%b8%8a%e4%b8%8b%e6%96%87">9.2 中断上下文</h3>
<p><code>中断上文</code>：硬件通过中断触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理。中断上文可以看作就是硬件传递过来的这些参数和内核需要保存的一些其他环境（主要是当前被中断的进程环境。</p>
<p><code>中断下文</code>：执行在内核空间的中断服务程序。<code>中断上下文和特定进程无关</code>。</p>
<h3 id="93-%e4%b8%ad%e6%96%ad%e4%b8%8a%e4%b8%8b%e6%96%87%e4%bb%a3%e7%a0%81%e4%b8%ad%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9">9.3 中断上下文代码中注意事项</h3>
<ul>
<li><code>睡眠或者放弃CPU。</code>由于中断上下文不属于任何进程，它与current没有任何关系（尽管此时current指向被中断的进程），所以中断上下文一旦睡眠或者放弃CPU，将无法被唤醒。所以也叫原子上下文（atomic context）。<code>中断服务子程序一定不能睡眠（或者阻塞）。</code></li>
<li><code>尝试获得信号量。</code>为了保护中断句柄临界区资源，不能使用mutexes。如果获得不到信号量，代码就会睡眠，会产生和上面相同的情况，如果必须使用锁，则使用spinlock。</li>
<li><code>执行耗时的任务。</code>中断处理应该尽可能快，因为内核要响应大量服务和请求，中断上下文占用CPU时间太长会严重影响系统功能。在中断处理例程中执行耗时任务时，应该交由中断处理例程底半部来处理。</li>
<li><code>访问用户空间的虚拟地址。</code>因为中断上下文是和特定进程无关的，它是内核代表硬件运行在内核空间，所以在终端上下文无法访问用户空间的虚拟地址。</li>
<li><code>中断处理例程不应该设置成reentrant（可被并行或递归调用的例程）。</code>因为中断发生时，preempt和irq都被disable，直到中断返回。所以中断上下文和进程上下文不一样，中断处理例程的不同实例，是不允许在SMP上并发运行的。</li>
<li><code>中断处理例程可以被更高级别的IRQ中断。</code>如果想禁止这种中断，可以将中断处理例程定义成快速处理例程，相当于告诉CPU，该例程运行时，禁止本地CPU上所有中断请求。这直接导致的结果是，由于其他中断被延迟响应，系统性能下降。</li>
</ul>
<h2 id="%e5%8d%81linux%e4%b8%ad%e6%96%ad%e6%9c%ba%e5%88%b6">十、Linux中断机制</h2>
<p>Linux将中断处理程序分解为两个半部：<code>顶半部（Top Half）</code>与<code>底半部（Bottom Half）</code>。</p>
<p><code>顶半部</code>用于完成尽量少的比较紧急的功能，其往往只是简单的读取寄存器中的中断状态，并在清除中断标志位后进行“登记中断”的操作，“登记中断”意味着将底半部处理程序挂到底半部执行队列中，这样，顶半部执行的速度很快，从而可以服务更多的中断请求。</p>
<p>底半部用来完成中断事件的绝大部分内容，其可以被新的中断打断，其相对来说并不是非常紧急的，而且相对耗时，故不再硬件中断服务程序中执行。</p>
<p>若中断本身的工作很少，完全可以不需要底半部，只在顶半部执行。</p>
<h3 id="101-%e5%ba%95%e5%8d%8a%e9%83%a8%e6%9c%ba%e5%88%b6">10.1 底半部机制</h3>
<p>Linux实现底半部的机制主要有<code>tasklet</code>、<code>工作队列</code>、<code>软中断</code>和<code>线程化irq</code>。</p>
<h4 id="1011-tasklet">10.1.1 tasklet</h4>
<p>tasklet的执行上下文是软中断，执行时机通常是顶半部返回的时候，秩序定义tasklet及其处理函数，并将二者关联即可。</p>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">xxx_do_tasklet</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)</span></span>;

<span class="hljs-comment">//定义名称为xxx_tasklet的tasklet，并与xxx_do_tasklet处理函数绑定。</span>
DECLARE_TASKLET(xxx_tasklet, xxx_do_tasklet, <span class="hljs-number">0</span>);

<span class="hljs-comment">/* 中断底半部 */</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">xxx_do_tasklet</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)</span>
</span>{
    ...
}

<span class="hljs-comment">/* 中断顶半部 */</span>
<span class="hljs-keyword">irqreturn_t</span> xxx_interrupt(<span class="hljs-keyword">int</span> irq, <span class="hljs-keyword">void</span> *dev_id)
{
    ...
    tasklet_schedule(&amp;xxx_tasklet);<span class="hljs-comment">//在适当的时候进行调度运行tasklet</span>
    ...
}

<span class="hljs-comment">/* 设备驱动模块加载函数 */</span>
<span class="hljs-keyword">int</span> __<span class="hljs-function">init <span class="hljs-title">xxx_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    ...
    <span class="hljs-comment">/* 申请中断 */</span>
    result = request_irq(xxx_irq, xxx_interrupt, <span class="hljs-number">0</span>, <span class="hljs-string">"xxx"</span>, <span class="hljs-literal">NULL</span>);
    ...

    <span class="hljs-keyword">return</span> IRQ_HANDLED;
}

<span class="hljs-comment">/* 设备驱动模块卸载函数 */</span>
<span class="hljs-keyword">void</span> __<span class="hljs-function"><span class="hljs-built_in">exit</span> <span class="hljs-title">xxx_exit</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    ...
    <span class="hljs-comment">/* 释放中断 */</span>
    free_irq(xxx_irq, xxx_interrupt);
    ...
}

</div></code></pre>
<h4 id="1012-%e5%b7%a5%e4%bd%9c%e9%98%9f%e5%88%97">10.1.2 工作队列</h4>
<p>工作队列的执行上下文是内核线程，因此可以调度和睡眠。</p>
<pre><code class="language-c"><div><span class="hljs-comment">/* 定义工作队列和关联函数 */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_struct</span> <span class="hljs-title">xxx_wq</span>;</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">xxx_do_work</span><span class="hljs-params">(struct work_struct *work)</span></span>;

<span class="hljs-comment">/* 中断底半部 */</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">xxx_do_work</span><span class="hljs-params">(struct work_struct *work)</span>
</span>{
    ...
}

<span class="hljs-comment">/* 中断顶半部 */</span>
<span class="hljs-keyword">irqreturn_t</span> xxx_interrupt(<span class="hljs-keyword">int</span> irq, <span class="hljs-keyword">void</span> *dev_id)
{
    ...
    schedule_work(&amp;xxx_wq);
    ...
    <span class="hljs-keyword">return</span> IRQ_HANDLED;
}

<span class="hljs-comment">/* 驱动加载函数 */</span>
<span class="hljs-keyword">int</span> __<span class="hljs-function">init <span class="hljs-title">xxx_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    ...
    <span class="hljs-comment">/* 申请中断 */</span>
    result = request_irq(xxx_irq, xxx_interrupt, <span class="hljs-number">0</span>, <span class="hljs-string">"xxx"</span>, <span class="hljs-literal">NULL</span>);
    ...

    <span class="hljs-comment">/* 初始化工作队列 */</span>
    INIT_WORK(&amp;xxx_wq, xxx_do_work);
    ...
}

<span class="hljs-comment">/* 模块卸载函数释放中断 */</span>
...
</div></code></pre>
<h4 id="1013-%e8%bd%af%e4%b8%ad%e6%96%ad">10.1.3 软中断</h4>
<p>软中断和tasklet运行于软中断上下文，依然属于原子上下文，二工作队列运行于进程上下文，故在软中断和tasklet处理函数中不允许睡眠，而在工作队列处理函数中允许睡眠。</p>
<h4 id="1014-%e7%ba%bf%e7%a8%8b%e5%8c%96irqthreadedirq">10.1.4 线程化irq（threaded_irq）</h4>
<p>在内核中除了可以通过request_irq()、devm_request_irq()申请中断外，还可以通过下列两个函数申请中断：</p>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">request_threaded_irq</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> irq, <span class="hljs-keyword">irq_handler_t</span> handler,
                        <span class="hljs-keyword">irq_handler_t</span> thread_fn,
                        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> flags, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">void</span> *dev)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">devm_request_threaded_irq</span><span class="hljs-params">(struct device *dev, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> irq,
                            <span class="hljs-keyword">irq_handler_t</span> handler, <span class="hljs-keyword">irq_handler_t</span> thread_fn,
                            <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> irqflags, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *devname,
                            <span class="hljs-keyword">void</span> *dev_id)</span></span>;
</div></code></pre>
<p>在用上述两个API申请中断时，内核会为每个中断号分配一个内核线程<code>thread_fn</code>，内核线程调度thread_fn对应的执行函数。</p>
<h2 id="%e5%8d%81%e4%b8%80%e6%97%a0%e7%ba%bf%e9%9f%b3%e4%b9%90%e6%92%ad%e6%94%be%e7%b3%bb%e7%bb%9f%e9%a1%b9%e7%9b%ae">十一、无线音乐播放系统项目</h2>
<h3 id="111-wav%e6%a0%bc%e5%bc%8f%e6%96%87%e4%bb%b6">11.1 WAV格式文件</h3>
<p>WAV格式通常用来保存PCM（脉冲编码调制）格式的原始音频数据。PCM文件就是AD转换后得到的二进制数据文件，将PCM加上文件头和文件尾就成了WAV文件。44100HZ 16bit stereo: 每秒钟有 44100 次采样, 采样数据用 16 位(2字节)记录, 双声道(立体声);22050HZ 8bit  mono: 每秒钟有 22050 次采样, 采样数据用 8 位(1字节)记录, 单声道;人对频率的识别范围是 20HZ - 20000HZ, 如果每秒钟能对声音做 20000 个采样, 回放时就足可以满足人耳的需求. 所以 22050 的采样频率是常用的。1 字节(也就是8bit) 只能记录 256 个数, 也就是只能将振幅划分成 256 个等级;</p>
<h3 id="112-pwm%e9%a9%b1%e5%8a%a8%e9%9f%b3%e5%93%8d%e6%92%ad%e6%94%be%e8%bf%87%e7%a8%8b">11.2 PWM驱动音响播放过程</h3>
<p>PWM信号可看作一个直流信号与锯齿波比较得到的信号，其占空比反映了直流信号的大小，所以PWM经低通滤波之后可以恢复直流信号，直流信号的大小由占空比决定。PWM做音频输出时，其频率是固定的（这个频率决定声调，一般的语音信号取11.025kHz。），然后将PCM文件中的数据作为占空比大小输出PWM波，经低通滤波后驱动扬声器即可得到声音。</p>
<p>由于使用用D/A转换器实现模拟量的输出成本较高，音质效果也不佳。项目所选用的STC15F2K60S2单片机用过PCA通道调制8位的PWM信号，还原8位单声道的WAV声音文件。</p>
<p>我们采用的是8位单声道，采样频率为12200Hz的采样文件，与串口波特率115200相结合，进行音乐播放。</p>
<p>设置定时器的输出频率为WAV文件的采样频率就可以对原WAV格式的文件进行还原，定时器0的工作在16位自动重装载模式下，且工作在1T（不分频）模式时，定时器的输出频率为：</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>p</mi><mi>w</mi><mi>m</mi></mrow></msub><mo>=</mo><mi>s</mi><mi>y</mi><mi>s</mi><mi>c</mi><mi>l</mi><mi>k</mi><mo>÷</mo><mo stretchy="false">(</mo><mn>65536</mn><mo>−</mo><mo stretchy="false">[</mo><mi>R</mi><mi>L</mi><mi mathvariant="normal">_</mi><mi>T</mi><mi>H</mi><mn>0</mn><mo separator="true">,</mo><mi>R</mi><mi>L</mi><mi mathvariant="normal">_</mi><mi>T</mi><mi>L</mi><mn>0</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>÷</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">f_{pwm} = sysclk \div (65536 - [RL\_TH0, RL\_TL0])\div2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mord">5</span><span class="mord">5</span><span class="mord">3</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">L</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">L</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">L</span><span class="mord">0</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></p>
<p>故设置定时器的自动重装载值为：</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>R</mi><mi>L</mi><mi mathvariant="normal">_</mi><mi>T</mi><mi>H</mi><mn>0</mn><mo separator="true">,</mo><mi>R</mi><mi>L</mi><mi mathvariant="normal">_</mi><mi>T</mi><mi>L</mi><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mn>65536</mn><mo>−</mo><mi>s</mi><mi>y</mi><mi>s</mi><mi>c</mi><mi>l</mi><mi>k</mi><mo>÷</mo><mo stretchy="false">(</mo><msub><mi>f</mi><mrow><mi>p</mi><mi>w</mi><mi>m</mi></mrow></msub><mo>×</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[RL\_TH0, RL\_TL0] = 65536 - sysclk \div (f_{pwm} \times 2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">L</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">L</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">L</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mord">5</span><span class="mord">5</span><span class="mord">3</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span></p>

    </body>
    </html>