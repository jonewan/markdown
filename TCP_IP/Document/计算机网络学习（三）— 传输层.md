# 计算机网络学习（三）— 传输层

## 一、传输层协议的应用场景

* TCP保证可靠传输，需要分段，并对每个分段编号，具有流量控制功能，需要建立会话。
* UDP传输不编号，一个数据包就能完成数据通信，不建立会话，多播。

### 1.1 场景分析

在使用微信聊天与传输文件时分别采用什么协议？

在聊天时不需要知道对方是否存在，是面向无连接的通信，因此使用UDP协议进行通信。而在传输文件时，一个数据包并不能传输完成，并且要求文件的正确性与可靠性，因此，传输文件采用的是TCP协议。

## 二、传输层与应用层的关系

应用层协议其实就是传输层协议TCP或UDP加上相应的端口号，例如以下常用的应用层协议与其对应的传输层协议加端口。

应用层协议 | 传输层协议 + 端口
:--:|:--:
http | TCP + 80
HTTPS | TCP + 443
FTP | TCP + 21
SMTP | TCP + 25
POP3 | TCP + 110
RDP | TCP + 3389
DNS | UDP/TCP + 53

应用层协议与服务的关系就是：服务运行后在TCP或UDP的某个端口来侦听客户端的请求。

### 2.1 三类端口

* 众所周知的端口：数值一般为0~1023
* 登记端口号：1024~49151（魔数常量）
* 客户端口号：49152~65535

在使用客户端访问服务端的指定端口时，服务端的端口号是指定的，而客户端的端口号是`随机的`，例如可以用客户端的任意端口去连接服务端的web服务80端口。

## 三、UDP协议

UDP在传输数据之前不需要先建立连接，对方的运输层在收到UDP报文后不需要给出任何确认，虽然UDP不提供可靠交付，但在某些情况下是一种最有效的工作方式。

### 3.1 UDP的特点

* 面向无连接的，即发送数据前不需要建立连接
* 不保证可靠交付，同时也不具有拥塞控制
* 面向报文的，适合多媒体通信需求
* 支持一对一、一对多、多对一、多对多的交互通信
* 首部开销小，只需8个字节，有四个字段，每个字段两字节：
  * 源端口
  * 目的端口
  * 长度：UDP数据包长度
  * 检验和：检测UDP用户数据报在传输中是否有错。有错就丢弃。

![UDP首部](https://github.com/jonewan/markdown/blob/master/TCP_IP/UDP%E9%A6%96%E9%83%A8.jpg?raw=true)

## 四、TCP（传输控制协议）协议

TCP则提供面向连接的服务，TCP不提供广播或多播服务，由于TCP要提供可靠的、面向连接的运输服务，因此不可避免的增加了许多开销。

### 4.1 TCP特点

* 面向连接的传输层协议
* 每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）
* 提供可靠交付的服务：通过TCP连接传送的数据，无差错、不丢失、不重复，并且按序到达。
* 提供全双工通信
* 面向字节流

TCP把`连接`作为最基本的抽象，每一条TCP连接有两个端点，TCP连接的端点叫做套接字（socket），一个socket其实就是一个IP+端口号（IP:端口号）。每一条TCP连接唯一地被通信两端的两个端点（即两个套接字或叫套接字组）所确定。

### 4.2 TCP如何实现可靠传输

TCP发送的报文段是交给IP层传送的，但IP层只能提供尽最大努力服务，也就是说，TCP下面的网络所提供的是不可靠的传输。TCP利用`停止等待协议`保证可靠传输。“停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。

#### 4.2.1 停止等待与超时重传

在`没有出现差错的情况`下，发送端A发送完一组数据就停止发送，等待接收端B发送一个确认信号，A在收到B的确认信号之后继续发送下一组数据，之后等待确认，一次循环此操作。

接收端B接收到了有差错的数据包，或者某一个数据包在传输过程中丢失了，这就是`有差错的情况`，在此情况下接收方B将此数据包丢弃，或什么也不做，不会发送任何信息。为了保证可靠传输，发送方A采用`超时重传机制`（A只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，因而重传前面发送过的分组）。

要实现超时重传，就要在每发送完一个分组时设置一个`超时计时器`。如果在超时计时器到期之前收到了对方的确认，就撤销已设置的超时计时器。

* A在发送完一个分组后，必须暂时保留已发送的分组的副本,只有在收到相应的确认后才能清除暂时保留的分组副本。
* 分组和确认分组都必须进行编号,这样才能明确是哪一个发送出去的分组收到了确认，而哪一个分组还没有收到确认。
* 超时计时器设置的重传时间应当比数据在分组传输的平均往返时间(RTT)更长一些。

![停止等待与超时重传](https://raw.githubusercontent.com/jonewan/markdown/master/TCP_IP/%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E4%B8%8E%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0.jpg)

运输层的超时计时器的超时重传时间究竟应设置为多大呢？TCP采用了一种自适应算法，它记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是报文段的往返时间RTT 。TCP保留了RTT的一个加权平均往返时间$RTT_S$。

$新的RTT_s = （1 - \alpha）\times (旧的RTT_s) + \alpha \times (新的RTT样本)$

TCP建议$\alpha$的取值为1/8。超时计时器设置的超时重传时间 RTO（RetransmissionTime-Out）的计算方法如下：

$RTO = RTT_S + 4 \times RTT_D$

$RTT_D$是RTT的偏差的加权平均，其计算公式如下：

$新的RTT_D = （1 - \beta）\times (旧的RTT_s) + \beta \times |RTT_S - 新的RTT样本|$

$\beta$的推荐值为1/4。

报文段每重传一次，就把超时重传时间RTO增大一些。典型的做法是取新的重传时间为旧的重传时间的2倍。当不再发生报文段的重传时，才根据上面给出的公式式计算超时重传时间。

#### 4.2.2 确认丢失和确认迟到

在A向B发送一个数据包后，数据包正常到达，之后B向A发送确认信号ACK，但是由于网络原因ACK丢失了，这就叫`确认丢失`。这时A没有收到ACK就会对该数据包进行超时重传，之后B会重新收到相同的数据包，B采取的操作为：

* 丢弃这个重复的分组
* 重新向A发送确认信号ACK

在A向B发送一个数据包后，数据包正常到达，之后B向A发送确认信号ACK，但是由于网络原因ACK选择了一条较远的路由，导致A的超时重传启动，这时B会重新收到相同的数据包，B将该重复的包丢弃，重新发送ACK，A接受到ACK之后继续发送后续数据，这时之前的ACK到达了A端，A会直接将该确认信号丢弃，这叫做`确认迟到`。

![确认丢失和确认迟到](https://github.com/jonewan/markdown/blob/master/TCP_IP/%E7%A1%AE%E8%AE%A4%E4%B8%A2%E5%A4%B1%E5%92%8C%E7%A1%AE%E8%AE%A4%E8%BF%9F%E5%88%B0.jpg?raw=true)

上述的这种可靠传输协议常称为`自动重传请求ARQ（Automatic Repeat reQuest）`。意思是重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组。

为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用`流水线传输`。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断地在传送。

当使用流水线传输时，就要使用`连续ARQ协议`和`滑动窗口协议`。

#### 4.2.3 连续ARQ协议

发送方A维持一个`发送窗口`，位于发送窗口内的每个分组都可连续发送出去，而不需要等待对方的确认。连续ARQ协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。位于窗口内的分组不能删除，只有窗口滑过之后才可删除。接收方一般都是采用`累积确认`的方式，不必对收到的分组逐个发送确认，而是在收到几个分组后，对按序到达的最后一个分组发送确认，表示到这个分组为止的所有分组都已正确收到了。

如果发送方发送了前5个分组，而中间的第3个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。当通信线路质量不好时，连续ARQ协议会带来负面的影响。

#### 4.2.4 TCP首部

TCP报文段首部的前20个字节是固定的，后面有4n 字节是根据需要而增加的选项（n 是整数）。因此TCP首部的最小长度是20字节。

首部固定部分各字段的意义如下：

* 源端口和目的端口：各占2个字节。
* 序号：占4字节，表示该报文段的`第一个字节`的编号（一个TCP连接中传送的字节流中的每一个字节都按顺序编号）。
* 确认号：占4字节，表示下一次该发哪一个字节开始的数据包了。若确认号为N，则表示0~N–1都正确接收了。
* 数据偏移：占4位二进制，用来记录TCP真正的数据在整个报文段的位置。数据偏移的最大值是60字节（数据偏移为1111）。
* 保留：占6位。
* 紧急 URG（Urgent）：当URG＝1时，表明此报文段中有紧急数据，应该先传送紧急数据，之后再按顺序传送报文段中的其他数据。与`紧急指针`配合使用。
* 确认ACK（Acknowledgment）
* 推送PSH（Push）
* 复位RST（Reset）：当RST＝1时，表明TCP连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。
* 同步位SYN（Synchronization）
* 终止位FIN（Finish）
* 窗口：占2字节，告诉对方自己的接收缓存大小（字节数），用于让发送方设置其发送缓存的大小。窗口值经常在动态变化着。
* 检验和：占2字节
* 紧急指针：占2字节
* 选项：长度可变，最长可达40字节

![TCP首部](https://github.com/jonewan/markdown/blob/master/TCP_IP/TCP%E9%A6%96%E9%83%A8.jpg?raw=true)

#### 4.2.5 以字节为单位的滑动窗口机制

TCP的滑动窗口是以`字节`为单位的。

发送缓存用来暂时存放：

* （1）发送应用程序传送给发送方TCP准备发送的数据；
* （2）TCP已发送出但尚未收到确认的数据。

`发送窗口`通常只是发送缓存的一部分。已被确认的数据应当从发送缓存中删除，未被确认的数据不能删，用于超时重传。

接收缓存用来暂时存放：

* （1）按序到达的、但尚未被接收应用程序读取的数据；
* （2）未按序到达的数据。

如果收到的分组被检测出有差错，则要丢弃。如果接收应用程序来不及读取收到的数据，接收缓存最终就会被填满，使接收窗口减小到零。若接收到的数据未按序，接收方可以发送SACK（选择确认，在建立TCP连接时，要在TCP首部的选项中加上“允许SACK”的选项），否则就需要将未确认的数据重传（大部分情况下）。

### 4.3 TCP如何实现流量控制

`流量控制（flow control）`就是让发送方的发送速率不要太快，要让接收方来得及接收。利用`滑动窗口机制`可以很方便地在TCP连接上实现对发送方的流量控制。流量控制往往是指点对点通信量的控制 ，是个端到端的问题（接收端控制发送端）。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。

### 4.4 TCP的传输效率

在TCP的实现中广泛使用`Nagle算法`，来控制TCP发送报文段的时机。若发送应用进程把要发送的数据逐个字节地送到TCP的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来。当发送方收到对第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文段发送出去，同时继续对随后到达的数据进行缓存。只有在收到对前一个报文段的确认后才继续发送下一个报文段。当数据到达较快而网络速率较慢时，用这样的方法可明显地减少所用的网络带宽。Nagle算法还规定，当到达的数据已达到发送窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段。这样做，就可以有效地提高网络的吞吐量。

### 4.4 TCP如何实现拥塞控制

在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，就会出现`拥塞`。拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。

TCP进行拥塞控制的算法有四种：`慢开始（slow-start）`、`拥塞避免（congestion avoidance）`、`快重传（fast retransmit）`和`快恢复（fast recovery）`。

发送方维持一个叫做拥塞窗口cwnd（congestion window),拥塞窗口的大小取决于网络的拥塞程度，且动态变化，发送方让自己的发送窗口等于拥塞窗口。

`慢开始`算法规定由小到大逐渐增大发送窗口，按指数型增长，增长到`慢开始门限（ssthresh）`。之后采用`拥塞避免`算法，对拥塞窗口进行线性增长，如果发现网络拥塞（出现超时），调整慢开始门限为当前拥塞窗口的一半（ssthresh = cwnd/2），然后再重新按照慢开始算法从初始拥塞窗口进行增加。

`快重传`算法的目的是让发送方尽早知道发生了个别报文段的丢失，当一个数据包丢失后立即发送确认，发送方只要一连收到3个重复确认，就知道接收方确实有包丢失，立即对丢失的报文进行重传（快重传）。发送方知道现在只是丢失了个别的报文段。于是`不启动慢开始`，而是执行`快恢复算法`，这时，发送方调整慢开始门限值ssthresh＝cwnd/2，同时设置拥塞窗口为慢开始门限值（cwnd＝ssthresh），并开始执行拥塞避免算法。

![拥塞控制](https://github.com/jonewan/markdown/blob/master/TCP_IP/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.jpg?raw=true)

### 4.5 TCP连接管理

TCP连接的建立采用客户服务器方式。主动发起连接建立的应用进程叫做`客户端（client）`，而被动等待连接建立的应用进程叫做`服务器（server）`。

#### 4.5.1 三次握手

![三次握手](https://github.com/jonewan/markdown/blob/master/TCP_IP/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg?raw=true)

* 为什么需要第三次握手？第三次握手失败了会怎么样？

第三次握手是为了避免A发送的已经失效的连接请求又传到B，假设A发送了连接请求，由于网络原因SYN信号延时了，A超时重发SYN，之后B对A的SYN进行确认，若此时双方就简历了连接，则过一段时间之前的SYN信号到达B，B重新对SYN进行确认，而A不再理会B重新发送的确认信号，导致B资源的浪费。若第三次握手失败，则服务端发送RST信号，并主动断开连接进入CLOSED状态。

#### 4.5.2 四次挥手

![四次挥手](https://github.com/jonewan/markdown/blob/master/TCP_IP/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg?raw=true)

* 为什么有TIME_WAIT状态？

MSL称为`最长报文段寿命`，TIME_WAIT状态需要等待2MSL有两个原因，第一个原因是为了等待A发送的最后一个确认信号ACK能发送到B，若ACK丢失，则B需要重发FIN+ACK，A收到FIN+ACK后将2MSL计时器复位并重新发送确认信号。第二个原因就是为了保证在建立新的连接时，旧连接的报文段已经在网络中消失。确保新建立连接的正确性。
